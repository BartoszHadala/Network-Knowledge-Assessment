@startuml architecture
!theme plain
title System Architecture - Network Knowledge Test

package "Client Side" {
    [Client Application] as client
    [Menu UI] as menu
    [TLV Client] as tlv_c
    [Display Utils] as display
}

package "Network" {
    [TCP/IPv6 Socket] as socket
    [Multicast Discovery] as discovery
}

package "Server Side (Daemon)" {
    [Server Main] as server
    [Epoll Event Loop] as epoll
    [TLV Server] as tlv_s
    [Server Utils] as sutils
    [Quiz Engine] as quiz
    [Rankings Manager] as rankings
    [Statistics Collector] as stats
}

package "Storage" {
    database "questions.json" as qdb
    file "syslog" as log
}

client --> menu
menu --> tlv_c
tlv_c --> display
tlv_c --> socket

socket <--> tlv_s
discovery --> socket

server --> epoll
epoll --> tlv_s
tlv_s --> sutils
tlv_s --> quiz
tlv_s --> rankings
tlv_s --> stats

quiz --> qdb
server --> log

note right of server
  Unix Daemon
  - Double fork
  - setsid()
  - syslog logging
end note

note right of epoll
  Event-driven I/O
  - Non-blocking sockets
  - Edge-triggered mode
  - Up to 2000 connections
end note

@enduml

@startuml sequence_login
!theme plain
title Sequence Diagram - User Login

actor User
participant "Client" as C
participant "TCP Socket" as S
participant "Server" as SRV
participant "Server Utils" as SU

User -> C: Start client
C -> C: Connect to server\n(IP:PORT or --discover)
C -> SRV: TCP Connection
activate SRV

User -> C: Enter nickname
C -> C: Create TLV_LOGIN_REQUEST
C -> S: Send LOGIN_REQUEST\n{nick_length, nick}
S -> SRV: Deliver message

SRV -> SU: server_handle_login()
activate SU

SU -> SU: Parse nickname
SU -> SU: Validate format\n(length, chars)

alt Valid & Available
    SU -> SU: Add to active_nicks[]
    SU -> SU: Save to connection_nicks[]
    SU -> SU: Create LOGIN_RESPONSE\n(status=SUCCESS)
    SU -> S: Send response
    S -> C: Deliver response
    C -> User: "Login successful!"
else Invalid or Taken
    SU -> SU: Create LOGIN_RESPONSE\n(status=ERROR)
    SU -> S: Send response
    S -> C: Deliver response
    C -> User: "Login failed:\n<error message>"
end

deactivate SU
deactivate SRV

@enduml

@startuml sequence_test
!theme plain
title Sequence Diagram - Knowledge Test (10 Questions)

actor User
participant "Client" as C
participant "Server" as S
participant "Quiz DB" as Q
participant "Statistics" as ST

User -> C: Select option 2\n(Knowledge Test)
C -> C: Start timer\n(time_start)

loop 10 times (i = 0..9)
    C -> S: REQUEST_QUESTION\n{mode=TEST, index=i}
    S -> Q: quiz_get_random_question()
    activate Q
    Q -> S: Return Question object
    deactivate Q
    
    S -> C: QUESTION_DATA\n{id, question, answers[]}
    C -> User: Display question\n+ 4 answers (A-D)
    
    User -> C: Select answer (A-D)
    C -> S: ANSWER_SUBMIT\n{question_id, answer_id}
    
    S -> Q: quiz_check_answer()
    activate Q
    Q -> S: is_correct (0/1)
    deactivate Q
    
    S -> C: ANSWER_RESULT\n{is_correct, correct_answer_id}
    
    alt Correct answer
        C -> C: correct_count++
        C -> User: "✓ Correct!"
    else Wrong answer
        C -> User: "✗ Wrong!\nCorrect: <answer>"
    end
    
    alt Not last question
        C -> User: "Press Enter to continue..."
        User -> C: <Enter>
    end
end

C -> C: Calculate elapsed time\n(time_end - time_start)
C -> User: Display final score\n"Score: X/10\nTime: MM:SS"

C -> S: SUBMIT_SCORE\n{score, time_seconds}

S -> ST: Update statistics
activate ST
ST -> ST: tests_completed++
ST -> ST: total_score += score
ST -> ST: Update best_score if needed
deactivate ST

S -> S: Save to rankings[]\n{nick, score, time}

@enduml

@startuml sequence_ranking
!theme plain
title Sequence Diagram - View Rankings

actor User
participant "Client" as C
participant "Server" as S
participant "Rankings\nManager" as R

User -> C: Select option 3\n(Rankings)
C -> S: REQUEST_RANKING

S -> R: Lock rankings_mutex
activate R
R -> R: Copy rankings[] to sorted[]
R -> R: Sort by:\n1. score (DESC)\n2. time (ASC)
R -> R: Take top 10
R -> S: Return sorted list\n{nicks[], scores[], times[]}
deactivate R
S -> S: Unlock rankings_mutex

S -> C: RANKING_DATA\n{count, entries[]}

C -> C: Parse entries
C -> User: Display table:\n╔════════════════════╗\n║ TOP 10 RANKING     ║\n╠════════════════════╣\n║ 1. Janek 10/10 ... ║\n║ 2. Anna  9/10  ... ║\n╚════════════════════╝

@enduml

@startuml sequence_serverinfo
!theme plain
title Sequence Diagram - Server Information

actor User
participant "Client" as C
participant "Server" as S
participant "Statistics" as ST
participant "Quiz DB" as Q

User -> C: Select option 4\n(Server Info)
C -> S: REQUEST_SERVER_INFO

S -> ST: Lock stats_mutex
activate ST
ST -> ST: current_time = time(NULL)
ST -> ST: uptime = current_time - start_time
ST -> ST: avg_score = total_score / tests_completed
ST -> S: Return all statistics
deactivate ST
S -> S: Unlock stats_mutex

S -> Q: Get quiz_db.count
activate Q
Q -> S: Number of questions
deactivate Q

S -> C: SERVER_INFO_DATA\n{uptime, connections,\ntests, avg_score, best_score,\nbest_player, port, ...}

C -> C: Parse data
C -> C: Format uptime\n(days, hours, minutes)
C -> User: Display info:\n╔═══════════════════╗\n║ SERVER INFO       ║\n╠═══════════════════╣\n║ Uptime: 2h 34m    ║\n║ Connections: 47   ║\n║ Tests: 15         ║\n║ Avg Score: 7/10   ║\n║ Best: Janek 10/10 ║\n╚═══════════════════╝

@enduml

@startuml class_server
!theme plain
title Class Diagram - Server Components

class "struct server_stats" as stats {
    +time_t start_time
    +uint32_t total_connections
    +uint32_t active_connections
    +uint32_t tests_completed
    +uint32_t questions_asked
    +uint32_t total_score
    +uint8_t best_score
    +uint32_t best_time
    +char best_player[32]
}

class "struct score_entry" as score {
    +char nick[32]
    +uint8_t score
    +uint32_t time_seconds
}

class QuizDatabase {
    +Question *questions
    +int count
    +int capacity
    --
    +quiz_load_questions()
    +quiz_get_random_question()
    +quiz_get_question_by_id()
    +quiz_check_answer()
}

class Question {
    +int id
    +char pytanie[512]
    +char odpowiedzi[4][256]
    +int num_odpowiedzi
    +int poprawna
}

class "struct connection" as conn {
    +int fd
    +bool is_listener
    +uint8_t rbuf[8192]
    +size_t rlen, rpos
    +uint8_t wbuf[8192]
    +size_t wlen, wpos
    +enum parse_state state
    +uint16_t tlv_type
    +uint16_t tlv_len
}

class ServerMain {
    +int main(argc, argv)
    +void signal_handler(int)
    --
    -int listenfd
    -int epollfd
    -QuizDatabase quiz_db
    -score_entry rankings[100]
    -server_stats stats
    -char connection_nicks[2000][32]
}

class ServerUtils {
    +server_handle_login()
    +server_validate_nick()
    +server_is_nick_taken()
    +get_local_ip()
}

class TLVProtocol {
    +tlv_create_*()
    +tlv_parse_*()
    --
    Types:
    - LOGIN_REQUEST/RESPONSE
    - REQUEST_QUESTION
    - QUESTION_DATA
    - ANSWER_SUBMIT/RESULT
    - SUBMIT_SCORE
    - REQUEST_RANKING
    - RANKING_DATA
    - REQUEST_SERVER_INFO
    - SERVER_INFO_DATA
}

ServerMain --> QuizDatabase : uses
ServerMain --> stats : has
ServerMain --> score : has array
ServerMain --> conn : manages
ServerMain --> ServerUtils : calls
ServerMain --> TLVProtocol : uses
QuizDatabase --> Question : contains

@enduml

@startuml class_client
!theme plain
title Class Diagram - Client Components

class ClientMain {
    +int main(argc, argv)
    --
    -int sockfd
    -char server_ip[]
    -int port
    -bool running
}

class MenuInterface {
    +menu_display()
    +menu_clear_input_buffer()
    --
    Options:
    1. Random Question
    2. Test (10 questions)
    3. Rankings
    4. Server Info
    5. Exit
}

class ClientUtils {
    +client_login()
    +client_request_question()
    +client_submit_answer()
    +client_handle_single_question()
    +client_request_ranking()
    +client_request_server_info()
}

class DisplayUtils {
    +display_question()
    +display_rankings()
    +display_server_info()
    +display_test_result()
    --
    Features:
    - Word wrapping (70 chars)
    - Box drawing characters
    - Answer labeling (A-D)
}

class TLVProtocol {
    +tlv_create_*()
    +tlv_parse_*()
    --
    Same as server
}

class MulticastDiscovery {
    +discover_server()
    --
    - Join multicast group
    - Listen for announcements
    - Extract IP:PORT
}

ClientMain --> MenuInterface : uses
ClientMain --> ClientUtils : calls
ClientUtils --> TLVProtocol : uses
ClientUtils --> DisplayUtils : uses
ClientMain --> MulticastDiscovery : optional

note right of DisplayUtils
  Formats:
  - Questions with wrapping
  - Rankings table
  - Server info table
  - Score display
end note

@enduml

@startuml state_client
!theme plain
title State Diagram - Client Application

[*] --> Disconnected

Disconnected --> Connecting : Start client
Connecting --> Connected : TCP connect OK
Connecting --> Disconnected : Connect failed

Connected --> LoggingIn : Send LOGIN_REQUEST
LoggingIn --> MainMenu : Login SUCCESS
LoggingIn --> Disconnected : Login FAILED

state MainMenu {
    [*] --> Idle
    Idle --> RandomQuestion : Option 1
    Idle --> TestMode : Option 2
    Idle --> ViewRankings : Option 3
    Idle --> ServerInfo : Option 4
    Idle --> Exit : Option 5
    
    RandomQuestion --> Idle : Complete
    TestMode --> Idle : Complete
    ViewRankings --> Idle : Complete
    ServerInfo --> Idle : Complete
}

state TestMode {
    [*] --> StartTimer
    StartTimer --> AskQuestion
    AskQuestion --> DisplayQuestion
    DisplayQuestion --> WaitAnswer
    WaitAnswer --> SubmitAnswer
    SubmitAnswer --> ShowResult
    ShowResult --> CheckCount
    CheckCount --> AskQuestion : i < 10
    CheckCount --> EndTest : i == 10
    EndTest --> SubmitScore
    SubmitScore --> [*]
}

MainMenu --> Disconnected : Exit or Error
Exit --> [*]

@enduml

@startuml state_server
!theme plain
title State Diagram - Server Daemon

[*] --> Starting

Starting --> LoadingQuiz : Initialize
LoadingQuiz --> Daemonizing : Questions loaded
LoadingQuiz --> Error : Load failed

Daemonizing --> Running : daemon_init() OK
Daemonizing --> Error : daemon_init() failed

state Running {
    [*] --> EpollWait
    
    EpollWait --> AcceptConnection : New connection
    EpollWait --> HandleMessage : Data ready
    EpollWait --> CheckShutdown : Timeout
    
    AcceptConnection --> UpdateStats : Connection accepted
    UpdateStats --> EpollWait
    
    HandleMessage --> ParseTLV
    ParseTLV --> ProcessLogin : LOGIN_REQUEST
    ParseTLV --> ProcessQuestion : REQUEST_QUESTION
    ParseTLV --> ProcessAnswer : ANSWER_SUBMIT
    ParseTLV --> ProcessScore : SUBMIT_SCORE
    ParseTLV --> ProcessRanking : REQUEST_RANKING
    ParseTLV --> ProcessServerInfo : REQUEST_SERVER_INFO
    
    ProcessLogin --> SendResponse
    ProcessQuestion --> SendResponse
    ProcessAnswer --> SendResponse
    ProcessScore --> UpdateStatistics
    UpdateStatistics --> SaveRanking
    SaveRanking --> EpollWait
    ProcessRanking --> SendResponse
    ProcessServerInfo --> SendResponse
    
    SendResponse --> EpollWait
    
    CheckShutdown --> EpollWait : Continue
    CheckShutdown --> Cleanup : shutdown_requested
}

Running --> Cleanup : SIGTERM/SIGINT

Cleanup --> [*] : closelog(), close sockets

Error --> [*]

note right of Running
  Event loop with epoll:
  - EPOLLIN: data ready
  - EPOLLERR: error
  - EPOLLHUP: hangup
end note

@enduml

@startuml component_tlv
!theme plain
title Component Diagram - TLV Protocol

package "TLV Protocol Layer" {
    component "TLV Header Parser" as parser {
        [Extract Type]
        [Extract Length]
        [Validate Format]
    }
    
    component "TLV Message Creators" as creators {
        [Login Messages]
        [Question Messages]
        [Answer Messages]
        [Score Messages]
        [Ranking Messages]
        [Server Info Messages]
    }
    
    component "TLV Message Parsers" as parsers {
        [Parse Login]
        [Parse Question]
        [Parse Answer]
        [Parse Score]
        [Parse Ranking]
        [Parse Server Info]
    }
    
    component "Byte Order Converter" as converter {
        [htons/ntohs]
        [htonl/ntohl]
    }
}

package "Application Layer" {
    component "Client App" as client
    component "Server App" as server
}

package "Transport Layer" {
    component "TCP Socket" as socket
}

client --> creators : Create messages
client --> parsers : Parse responses
server --> parsers : Parse requests
server --> creators : Create responses

creators --> converter : Convert to network byte order
parsers --> converter : Convert from network byte order

creators --> socket : send()
socket --> parsers : recv()
parser --> parsers : Header extraction

note right of converter
  All multi-byte integers
  use network byte order
  (big-endian)
end note

@enduml

@startuml deployment
!theme plain
title Deployment Diagram - Production Setup

node "Server Machine (Linux)" {
    component "Server Daemon" as daemon {
        port "TCP 7777" as port7777
        port "TCP 8888" as port8888
    }
    
    database "questions.json" as qjson
    database "/var/log/syslog" as syslog
    
    daemon --> qjson : read
    daemon --> syslog : write logs
}

node "Client Machine 1" {
    component "Client App" as client1
}

node "Client Machine 2" {
    component "Client App" as client2
}

node "Client Machine 3" {
    component "Client App" as client3
}

cloud "Network (IPv6)" {
    interface "Multicast\n224.0.0.251:5353" as multicast
}

client1 --> port7777 : TCP connection
client2 --> port7777 : TCP connection
client3 --> port8888 : TCP connection

daemon --> multicast : Announce server
client1 --> multicast : Discovery (optional)
client2 --> multicast : Discovery (optional)
client3 --> multicast : Discovery (optional)

note right of daemon
  Running as daemon:
  - PID file
  - syslog logging
  - Graceful shutdown
  - Signal handling
end note

note left of client1
  Modes:
  1. Direct: ./client IP PORT
  2. Discovery: ./client --discover
end note

@enduml
